<?php
namespace SaQle\Dao\Model;

use SaQle\Dao\Model\Interfaces\IModel;
use SaQle\Commons\StringUtils;
use SaQle\Http\Request\Request;
use SaQle\Services\Container\Cf;
use SaQle\Services\Container\ContainerService;
use SaQle\Dao\Model\Interfaces\ModelCollection;

#[\AllowDynamicProperties]
abstract class Model implements IModel{
	 use StringUtils;
	 public function __construct(...$kwargs){
	 	 $reflect = new \ReflectionClass($this);
	 	
	 	 $schema = $this->get_schema();
	 	 $db_columns = $schema->get_db_column_names();
	 	 $db_columns_flip = array_flip($db_columns);

         $typeMap = [
             'integer' => 'int',
             'boolean' => 'bool',
             'double'  => 'float',
         ];
	 	 
	 	 foreach($kwargs as $k => $v){
	 	 	 $real_key = array_key_exists($k, $db_columns) ? $k : ( array_key_exists($k, $db_columns_flip) ? $db_columns_flip[$k] : "" );

	 	 	 if($real_key && $reflect->hasProperty($real_key)){
	 	 	 	 $property = $reflect->getProperty($real_key);
                 $type = $property->getType();
                 if($type){
                 	 $expectedType = $type->getName();
                 	 if($type->isBuiltin()){
                 	 	 $actualType = gettype($v);

	                     if (isset($typeMap[$actualType])) {
	                        $actualType = $typeMap[$actualType];
	                     }

	                     if ($expectedType === $actualType) {
	                        $this->$real_key = $v;
	                     }
                 	 }else{
                 	 	 // Handle custom object types
                         if($v instanceof $expectedType) {
                             $this->$real_key = $v;
                         }
                 	 }  
                 }
	 	 	 }
	 	 }
	 }

	 /**
	  * Get the schema associated with model.
	  * */
	 protected static abstract function get_schema();

	 public function get_field_value($name){
	 	 return $this->$name;
	 }

	 public static function db2($table_name, $model_class, $db_class){
	 	 $manager = Cf::create(ContainerService::class)->createContextModelManager($db_class);
         $manager->initialize($table_name, $db_class, $model_class);
         return $manager;
	 }

	 public static function db(){
	 	 $called_class = get_called_class();
	 	 [$db_class, $table_name] = $called_class::get_schema()->get_table_n_dbcontext();
	 	 $manager = Cf::create(ContainerService::class)->createContextModelManager($db_class);
         $manager->initialize($table_name, $db_class);
         return $manager;
	 }

	 /**
	  * This save assumes the data was set via the model instructor.
	  * Notes on save:
	  * 1. By default only simple values are saved or updated when save is called.
	  * 2. Relation values(OneToOne, OneToMany, ManyToMany) will only be saved when explicitly requested via 'with' interface
	  * 3. While new relation objects can be created, they cannot be updated from here. Update relation ojects via their own models.
	  * 4. Values for properties that were not explicitly defined i.e values generated by auto_cm_fields, auto_cmdt_fields, soft_delete and enable_multitenancy flags will be filled in automatically. If there are values assigned for these properties here, they will be ignored.
	  * */
	 public function save(...$extra){
	 	 [$savable_simple, $savable_nk, $savable_fk, $pk_name] = $this->get_savable_values();
	 	 $with_fields = [];

	 	 /**
	 	  * If there are foreign relations, save them first.
	 	  * RK relations are one to one, so the save is expected to return a single object.
	 	  * */
	 	 $saved_fk_ids = [];
	 	 foreach($savable_fk as $fk_key => $fk_value){
	 	 	 $with_fields[] = $fk_key;
	 	 	 $s = $fk_value[0]->save();
	 	 	 if($s){
	 	 	 	 $fk_name = $fk_value[1]->get_fk();
	 	 	 	 $saved_fk_ids[$fk_key] = $s->get_field_value($fk_name);
	 	 	 }
	 	 }

	 	 /**
	 	  * Save the current object next.
	 	  * */
	 	 $object = null;
	 	 if(isset($savable_simple[$pk_name])){
	 	 	 $object = self::db()->where($pk_name, $savable_simple[$pk_name][0])->first_or_default(tomodel: true);
	 	 }

	 	 if(!$object){
	 	 	 $data = array_combine(array_keys($savable_simple), array_column(array_values($savable_simple), 0));
	 	 	 $object = self::db()->add(array_merge($data, $saved_fk_ids, $extra))->save(tomodel: true);
	 	 }

	 	 if(!$object){
	 	  	 throw new \Exception("Save operation aborted! This object could not be saved.");
	 	  	 return null;
	 	 }

	 	 /**
	 	  * If there are navgation relations, save them last.
	 	  * NK relations may return single object or a collection.
	 	  * */
	 	 $saved_nk_ids = [];
	 	 foreach($savable_nk as $nk_key => $nk_value){
	 	 	 $with_fields[] = $nk_key;
	 	 	 $nk_pk_name = $nk_value[1]->get_pk();
	 	 	 $nk_fk_name = $nk_value[1]->get_fk();
	 	 	 $nk_pk_value = $object->get_field_value($nk_pk_name);

	 	 	 if($nk_value[0] instanceof ModelCollection){
	 	 	 	 $s = $nk_value[0]->save();
 	 	 	 	 $saved_nk_ids[$nk_key] = [$nk_pk_value, $s->get_field_value($nk_fk_name), $nk_value[1]->get_through_model_schema(), $nk_pk_name, $nk_fk_name];
 	 	 	 }else{
 	 	 	 	 $nk_fk_name = $nk_value[1]->get_fk();
 	 	 	 	 $s = $nk_value[0]->save(...[$nk_fk_name => $nk_pk_value]);
 	 	 	 }
	 	 }

	 	 /**
	 	  * Tie the many to many relations via through model.
	 	  * */
	 	 foreach($saved_nk_ids as $_nk => $_ids){
	 	 	 if(count($_ids[1]) > 0){
		 	 	 $through_model_schema = $_ids[2];
		 	 	 $through_model = $through_model_schema[1]::state()->get_associated_model_class();
		 	 	 $data = [];
		 	 	 $pk_col_name = $_ids[3];
		 	 	 $fk_col_name = $_ids[4];
		 	 	 $pk_col_val = $_ids[0];
		 	 	 foreach($_ids[1] as $fk_col_val){
		 	 	 	 $data[] = [$pk_col_name => $pk_col_val, $fk_col_name => $fk_col_val];
		 	 	 }
		 	 	 $connected = $through_model::db2($through_model_schema[0], $through_model_schema[1], $through_model_schema[2])
		 	 	 ->add_multiple($data)->save();
		 	 }
	 	 }
	 	 $getmana = $this->db()->where($pk_name, $object->get_field_value($pk_name));
	 	 if($with_fields){
	 	 	$getmana->with($with_fields);
	 	 }

	 	 return $getmana->first_or_default(tomodel: true);
	 }

	 public function get_savable_values(){
	 	 $savable_simple = [];
	 	 $savable_fk = [];
	 	 $savable_nk = [];

	 	 $schema = $this->get_schema();
	 	 $defined_field_names = $schema->get_defined_field_names();
	 	 $nk_field_names = $schema->get_navigation_field_names();
	 	 $fk_field_names = $schema->get_fk_field_names();

	 	 $simple_fields = array_diff($defined_field_names, array_merge($nk_field_names, $fk_field_names));
	 	 $nk_fields = array_diff($defined_field_names, array_merge($simple_fields, $fk_field_names));
	 	 $fk_fields = array_diff($defined_field_names, array_merge($simple_fields, $nk_field_names));

	 	 $ref = new \ReflectionClass($this);
         $properties = $ref->getProperties(\ReflectionProperty::IS_PUBLIC);
	     foreach($properties as $property){
	     	 $property_name = $property->getName();
	     	 /**
              * Only take initialized properties. aka, properties with values
              * - validation mechanism will determine whether all the properties required for a successful save are there or not, so don't worry about it here.
              * Also take only those properties that wer explicitly defined on the schema associated with this model.
              * */
			 $rp = new \ReflectionProperty($this::class, $property_name);
			 if( $rp->isInitialized($this) && in_array($property_name, $defined_field_names) ){
			 	 $property_type = str_replace("?", "", $property->getType()); 
		     	 $property_value = $property->getValue($this);
		     	 if(in_array($property_name, $simple_fields)){
		     	 	 $savable_simple[$property_name] = [$property_value, false];
		     	 }elseif(in_array($property_name, $nk_fields)){
                     $savable_nk[$property_name] = [$property_value, $schema->is_include($property_name)];
		     	 }elseif(in_array($property_name, $fk_fields)){
                     $savable_fk[$property_name] = [$property_value, $schema->is_include($property_name)];
		     	 }
			 }
	     }

	     return [$savable_simple, $savable_nk, $savable_fk, $schema->get_pk_name()];
	 }

	 static public function get_collection_class(){
	 	 $model_dao_class      = get_called_class();
	 	 $nameparts            = explode("\\", $model_dao_class);
	 	 $model_dao_name       = array_pop($nameparts);
         $model_dao_namespace  = implode("\\", $nameparts);

         $collection_namespace = $model_dao_namespace."\\Collections";
         $collection_name      = $model_dao_name."Collection";
         return $collection_namespace."\\".$collection_name;
	 }
}
?>