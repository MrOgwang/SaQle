<?php
namespace SaQle\Dao\Model;

use SaQle\Dao\Model\Interfaces\IModel;
use SaQle\Commons\StringUtils;
use SaQle\Http\Request\Request;
use SaQle\Services\Container\Cf;
use SaQle\Services\Container\ContainerService;
use SaQle\Core\Collection\Base\TypedCollection;

#[\AllowDynamicProperties]
abstract class Model implements IModel{
	 use StringUtils;

	 private array $save_with = [];

	 public function __construct(...$kwargs){
	 	 $reflect = new \ReflectionClass($this);
	 	
	 	 $schema = $this->get_schema();
	 	 $db_columns = $schema->get_db_column_names();
	 	 $db_columns_flip = array_flip($db_columns);

         $typeMap = [
             'integer' => 'int',
             'boolean' => 'bool',
             'double'  => 'float',
         ];
	 	 
	 	 foreach($kwargs as $k => $v){
	 	 	 $real_key = array_key_exists($k, $db_columns) ? $k : ( array_key_exists($k, $db_columns_flip) ? $db_columns_flip[$k] : "" );

	 	 	 if($real_key && $reflect->hasProperty($real_key)){
	 	 	 	 $property = $reflect->getProperty($real_key);
                 $type = $property->getType();
                 if($type){
                 	 $expectedType = $type->getName();
                 	 if($type->isBuiltin()){
                 	 	 $actualType = gettype($v);

	                     if (isset($typeMap[$actualType])) {
	                        $actualType = $typeMap[$actualType];
	                     }

	                     if ($expectedType === $actualType) {
	                        $this->$real_key = $v;
	                     }
                 	 }else{
                 	 	 // Handle custom object types
                         if($v instanceof $expectedType) {
                             $this->$real_key = $v;
                         }
                 	 }  
                 }
	 	 	 }
	 	 }
	 }

	 /**
	  * Get the schema associated with model.
	  * */
	 protected static abstract function get_schema();

	 public function get_pk_value(){
	 	 $schema = $this->get_schema();
	 	 $pk_name = $schema->get_pk_name();
	 	 return $this->$pk_name;
	 }

	 public static function db(){
	 	 $called_class = get_called_class();
	 	 [$db_class, $table_name] = $called_class::get_schema()->get_table_n_dbcontext();
	 	 $manager = Cf::create(ContainerService::class)->createContextModelManager($db_class);
         $manager->initialize($table_name, $db_class);
         return $manager;
	 }

     /**
      * Relation objects will not be saved by default when saving main object, unless they are included
      * using the 'with' interface.
      * */
	 public function with(string $name){
	 	 if(!in_array($name, $this->save_with)){
	 	 	 $this->save_with[$name];
	 	 }
	 }

	 /**
	  * This save assumes the data was set via the model instructor.
	  * Notes on save:
	  * 1. By default only simple values are saved or updated when save is called.
	  * 2. Relation values(OneToOne, OneToMany, ManyToMany) will only be saved when explicitly requested via 'with' interface
	  * 3. While new relation objects can be created, they cannot be updated from here. Update relation ojects via their own models.
	  * 4. Values for properties that were not explicitly defined i.e values generated by auto_cm_fields, auto_cmdt_fields, soft_delete and enable_multitenancy flags will be filled in automatically. If there are values assigned for these properties here, they will be ignored.
	  * */
	 public function save(...$extra){
	 	 [$savable_simple, $savable_nk, $savable_fk, $pk_name] = $this->get_savable_values();

	 	 /**
	 	  * If there are foreign relations, save them first.
	 	  * RK relations are one to one, so the save is expected to return a single object.
	 	  * */
	 	 $saved_fk_ids = [];
	 	 foreach($savable_fk as $fk_key => $fk_value){
	 	 	 $s = $fk_value->save();
	 	 	 if($s){
	 	 	 	 $saved_fk_ids[$fk_key] = $s->get_pk_value();
	 	 	 }
	 	 }

	 	 /**
	 	  * Save the current object next.
	 	  * */
	 	 $object = null;
	 	 if(isset($savable_simple[$pk_name])){
	 	 	 $object = self::db()->where($pk_name, $savable_simple[$pk_name])->first_or_default(tomodel: true);
	 	 }

	 	 if(!$object){
	 	 	 $object = self::db()->add(array_merge($savable_simple, $saved_fk_ids, $extra))->save(tomodel: true);
	 	 }

	 	 if(!$object){
	 	  	 //throw a fail to save exception here!
	 	 }

	 	 /**
	 	  * If there are navgation relations, save them last.
	 	  * NK relations may return single object or a collection.
	 	  * */
	 	 $saved_nk_ids = [];
	 	 foreach($savable_nk as $nk_key => $nk_value){
	 	 	 if($nk_value instanceof TypedCollection){
	 	 	 	 $s = $nk_value->save();
 	 	 	 	 $saved_nk_ids[$nk_key] = $s->get_pk_values();
 	 	 	 }else{
 	 	 	 	 //$s = $nk_value->save(...[]);
 	 	 	 	 //$saved_nk_ids[$nk_key] = $s->get_pk_value();
 	 	 	 }
	 	 }

	 	 /**
	 	  * Tie the many to many relations via through model.
	 	  * */
	 	 foreach($saved_nk_ids as $_nk => $_ids){
	 	 	 
	 	 }

	 	 return $this->db()->where($pk_name, $object->get_pk_value())->first_or_default(tomodel: true);
	 }

	 public function get_savable_values(){
	 	 $savable_simple = [];
	 	 $savable_fk = [];
	 	 $savable_nk = [];

	 	 $schema = $this->get_schema();
	 	 $defined_field_names = $schema->get_defined_field_names();
	 	 $nk_field_names = $schema->get_navigation_field_names();
	 	 $fk_field_names = $schema->get_fk_field_names();

	 	 $simple_fields = array_diff($defined_field_names, array_merge($nk_field_names, $fk_field_names));
	 	 $nk_fields = array_diff($defined_field_names, array_merge($simple_fields, $fk_field_names));
	 	 $fk_fields = array_diff($defined_field_names, array_merge($simple_fields, $nk_field_names));

	 	 $ref = new \ReflectionClass($this);
         $properties = $ref->getProperties(\ReflectionProperty::IS_PUBLIC);
	     foreach($properties as $property){
	     	 $property_name = $property->getName();
	     	 /**
              * Only take initialized properties. aka, properties with values
              * - validation mechanism will determine whether all the properties required for a successful save are there or not, so don't worry about it here.
              * Also take only those properties that wer explicitly defined on the schema associated with this model.
              * */
			 $rp = new \ReflectionProperty($this::class, $property_name);
			 if( $rp->isInitialized($this) && in_array($property_name, $defined_field_names) ){
			 	 $property_type = str_replace("?", "", $property->getType()); 
		     	 $property_value = $property->getValue($this);
		     	 if(in_array($property_name, $simple_fields)){
		     	 	 $savable_simple[$property_name] = $property_value;
		     	 }elseif(in_array($property_name, $nk_fields)){
                     $savable_nk[$property_name] = $property_value;
		     	 }elseif(in_array($property_name, $fk_fields)){
                     $savable_fk[$property_name] = $property_value;
		     	 }
			 }
	     }

	     return [$savable_simple, $savable_nk, $savable_fk, $schema->get_pk_name()];
	 }
}
?>