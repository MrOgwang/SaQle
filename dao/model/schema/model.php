<?php
namespace SaQle\Dao\Model\Schema;

use SaQle\Dao\Field\Relations\Interfaces\IRelation;
use SaQle\Http\Request\Request;
use SaQle\Services\Container\ContainerService;
use SaQle\Services\Container\Cf;
use SaQle\Dao\Model\Attributes\{CreatorModifierFields, CreateModifyDateTimeFields, SoftDeleteFields};
use SaQle\Dao\Field\Interfaces\IField;
use SaQle\Dao\Field\Types\{Pk, TextField, OneToOne, OneToMany, FloatField, IntegerField, BigIntegerField, PhpTimestampField, ManyToMany, FileField, TinyTextField, DateField, TimeField, DateTimeField, TimestampField, BooleanField};
use SaQle\Dao\Field\Exceptions\FieldValidationException;
use SaQle\Security\Models\ModelValidator;
use SaQle\Commons\StringUtils;
use SaQle\Dao\Field\Types\Base\Relation;
use SaQle\Dao\Model\Manager\ModelManager;
use SaQle\Dao\Model\Interfaces\{IModel, IThroughModel, ITableSchema, ITempModel};

abstract class Model implements ITableSchema{
	 use StringUtils;

	 //static cache to store shared metadata per class
     private static array $shared_meta = [];

	 //all the extra information about a table scehema will be set on this
	 public private(set) TableInfo $meta {
	 	 set(TableInfo $value){
 	 	 	 $this->meta = $value;
 	 	 }

 	 	 get => $this->meta;
	 }

	 protected static array $instances = [];
	 
	 public function __construct(...$kwargs){
	 	 //initialize or reuse shared metadata for the concrete class
         $this->meta = $this->get_shared_meta(static::class);
	 	 [$db_class, $table_name] = self::get_table_n_dbcontext();
	 	 $this->meta->db_table    = $table_name;
	 	 $this->meta->db_class    = $db_class;
	 	 $this->meta->model_class = $this::class;
     }

     //method to ensure shared meta per class
     private function get_shared_meta(string $class_name): TableInfo {
         //Check if meta already exists for this class
         if(!isset(self::$shared_meta[$class_name])) {
             $table_info = new TableInfo();
             $this->model_setup($table_info);
             self::$shared_meta[$class_name] = $table_info;
         }

         //return the shared meta for this class
         return self::$shared_meta[$class_name];
     }

     //abstract method that must be implemented by concrete classes to define fields
     abstract protected function model_setup(TableInfo $meta): void;

     final public static function state(){
         $called_class = get_called_class();
         if (!isset($instances[$called_class])){
             $instances[$called_class] = new $called_class();
         }

         return $instances[$called_class];
     }

	 public static function db2($table_name, $model_class, $db_class, $table_aliase = null, $table_ref = null){
	 	 $manager = Cf::create(ContainerService::class)->createContextModelManager($db_class);
         $manager->initialize(
         	table_name:      $table_name, 
         	dbcontext_class: $db_class, 
         	model_class:     $model_class,
         	table_aliase:    $table_aliase,
         	table_ref:       $table_ref
         );
         return $manager;
	 }

	 public static function db($table_aliase = null, $table_ref = null){
	 	 $called_class = get_called_class();
	 	 [$db_class, $table_name] = $called_class::get_table_n_dbcontext();
	 	 
	 	 $manager = Cf::create(ContainerService::class)->createContextModelManager($db_class);
         $manager->initialize(
             table_name:      $table_name, 
         	 dbcontext_class: $db_class, 
         	 table_aliase:    $table_aliase,
         	 table_ref:       $table_ref
         );
         return $manager;
	 }

	 public static function get_table_n_dbcontext(){
	 	 $db_class = false;
	 	 $table_name = null;
	 	 $current_model_name = get_called_class();
	 	 $interfaces = class_implements($current_model_name);
	 	 
	 	 /**
	 	  * Note:
	 	  * For regular models defined by the user, the model is expected to have been registered with
	 	  * one or more database contexts.
	 	  * 
	 	  * For through models generated by makemigations command, the model may not be 
	 	  * registered with any databasecontext, therefore it will use the contexts of one of the related models.
	 	  * */
	 	 if(in_array(ITempModel::class, $interfaces)){
	 	 	 return ['', ''];
	 	 }elseif(in_array(IThroughModel::class, $interfaces)){
	 	 	 $related_models = $current_model_name::get_related_models();
	 	 	 if(!$related_models){
	 	 	 	throw new \Exception("A through model must have at least two related models!");
	 	 	 }

	 	 	 $first_model = $related_models[0];
	 	 	 [$db_class, $table_name] = $first_model::get_table_n_dbcontext();
	 	 }else{
	 	 	 $context_classes = array_keys(DB_CONTEXT_CLASSES);
		 	 for($x = 0; $x < count($context_classes); $x++){
		 	 	$context_class_name = $context_classes[$x];
		 	 	$models = $context_class_name::get_models();
		 	 	$model_classes = array_values($models);
		 	 	if(in_array($current_model_name, $model_classes)){
		 	 		$db_class = $context_class_name;
		 	 		$table_name = array_keys($models)[array_search($current_model_name, $model_classes)];
		 	 		break;
		 	 	}
		 	 }
	 	 } 

	 	 if(!$db_class || !$table_name){
	 	 	throw new \Exception($current_model_name.": Model not registered with any db contexts!");
	 	 }
	 	 return [$db_class, $table_name];
	 }

     public function get_validation_configurations(?array $field_names = null){
     	 $vc = [];
     	 foreach($this->meta->fields as $fn => $fv){
     	 	 $column_name = $fv->column_name;
     	 	 if(!$field_names || (($field_names && in_array($fn, $field_names)) || ($field_names && in_array($column_name, $field_names)))){
     	 	 	 $fvc = $fv->get_validation_configurations();
	     	 	 if($fvc){
	     	 	 	 $vc[$column_name] = $fvc;
	     	 	 }else{
	     	 	 	 $vc[$column_name] = false;
	     	 	 }
     	 	 }
     	 }
     	 return $vc;
     }

	 public function get_clean_data(array $data, string $operation = ''){
	 	 /**
	 	  * strip the data array of keys of the following:
	 	  * 1. All keys that are not field names of current model
	 	  * 2. PrimaryKey key: GUID key values will be auto generated by the application,
	 	  *    while AUTO key values are generated by the db engine on insert
	 	  * */
	 	 $original_data = $data;
     	 $tmp_data = [];
     	 $model_field_names = array_unique(array_merge(array_keys($this->meta->column_names), array_values($this->meta->column_names)));
     	 foreach(array_keys($data) as $_dk){
     	 	if(in_array($_dk, $model_field_names) && $_dk != $this->meta->pk_name && !in_array($_dk, $this->meta->nav_field_names)){
     	 		$tmp_data[$_dk] = $data[$_dk];
     	 	}
     	 }
     	 
     	 $data = $tmp_data;


         /**
          * The following field types will be excempted from validation, atleast for now.
          * 1. All navigation keys
          * 2. All file keys whose value in data is just file name. In the future, it should be possible
          *    to validate just the file name.
          * */
	 	 $vc = $operation == 'update' ? $this->get_validation_configurations(array_keys($data)) : $this->get_validation_configurations();
	 	 $file_names_only = [];
	 	 foreach($this->meta->file_field_names as $ffn){
	 	 	if(isset($data[$ffn]) && !is_array($data[$ffn])){
	 	 		$file_names_only[$ffn] = $data[$ffn];
	 	 	}
	 	 }

	 	 $exclude = array_merge(array_keys($file_names_only), $this->meta->nav_field_names);
	 	 foreach($vc as $vc_key => $vc_val){
	 	 	if(in_array($vc_key, $exclude)){
	 	 		unset($vc[$vc_key]);
	 	 	}
	 	 }

	 	 $validation_feedback = ModelValidator::validate($vc, $data);
		 if($validation_feedback["status"] !== 0){
			 throw new FieldValidationException([
			 	'model' => $this::class,
			 	'operation' => $operation,
			 	'dirty' => $validation_feedback['dirty']
			 ]);
		 }

		 /**
		  * In update operations, the primary key and value needs be reinserted into data here.
		  * TO DO: Find a way of avoiding this altogether.
		  * */
		 if($operation == 'update' && isset($original_data[$this->meta->pk_name])){
		 	$validation_feedback['clean'][$this->meta->pk_name] = $original_data[$this->meta->pk_name];
		 }
		 return array_merge($validation_feedback['clean'], $file_names_only);
	 }

     private function rename_uploaded_files(&$clean_data, $file_key, $rename_callback, $data_state = null){
	 	$original_clean_data = $clean_data;
	 	if(is_array($clean_data[$file_key]['name'])){
             foreach($clean_data[$file_key]['name'] as $n_index => $n){
                 $clean_data[$file_key]['name'][$n_index] = $this->$rename_callback(
                 	$data_state ? (Object)$data_state : (Object)$original_clean_data, 
                 	$clean_data[$file_key]['name'][$n_index], 
                 	$n_index
                 );
             }
         }else{
             $clean_data[$file_key]['name'] = $this->$rename_callback(
             	$data_state ? (Object)$data_state : (Object)$original_clean_data, 
             	$clean_data[$file_key]['name']
             );
         }
	 }

     public function get_file_configurations(){
     	 $fc = [];
     	 foreach($this->meta->file_field_names as $ffn){
     	 	$fc[$ffn] = $this->meta->fields[$ffn]->get_field_attributes();
     	 }
     	 return $fc;
     }

	 private function prepare_file_data(&$clean_data, $data_state = null){
	 	 /**
	 	  * Prepare files data: Only the file names will be saved in db.
	 	  * 1. Rename the files using the rename callback that was provided on the model if any
	 	  * 2. Get the file path using the path callback that was provided on the model if any.
	 	  * 3. Reset the file values in clean data to file names only
	 	  * */
	 	 $file_data = [];
	 	 foreach($this->meta->file_field_names as $ffn){
	 	 	$db_col = $this->meta->column_names[$ffn];
	 	 	#if the file exists.
	 	 	if(isset($clean_data[$db_col]) && is_array($clean_data[$db_col])){
	 	 		 $file_config = $this->meta->fields[$ffn]->get_field_attributes();

	 	 		 //rename files if a rename callback was provided.
	 	 		 if(isset($file_config['rename_callback'])){
	 	 		 	 $rename_callback = explode("(", $file_config['rename_callback'])[0];
	 	 		 	 if(method_exists($this, $rename_callback)){
	 	 		 	 	 $this->rename_uploaded_files($clean_data, $db_col, $rename_callback, $data_state);
	 	 		 	 }
	 	 		 }

	 	 		 //get the file path
	 	 		 $path = "";
	 	 		 if(isset($file_config['path'])){
	 	 		 	 $folder_path = explode("(", $file_config['path'])[0];
	 	 		 	 if(method_exists($this, $folder_path)){
	 	 		 	 	 $path = $this->$folder_path($data_state ? (Object)$data_state : (Object)$clean_data);
	 	 		 	 }
	 	 		 }
	 			 $file_config['path'] = $path;
	 			 $file_data[$db_col] = (Object)['file' => $clean_data[$db_col], 'config' => $file_config];

	 			 //reset the file value in clean data to file names only.
	     	     $clean_data[$db_col] = is_array($clean_data[$db_col]['name']) ? implode("~", $clean_data[$db_col]['name']) : $clean_data[$db_col]['name'];
	 	 	}
	 	 }
	 	 return $file_data;
	 }

	 private function check_if_duplicate($data, $table_name = null, $model_class = null, $db_class = null){
	 	 if(!$this->meta->unique_fields){
	 	 	 return false;
	 	 }

	 	 /**
	 	  * Check that the fields provided are defined in model.
	 	  * */
	 	 $all_defined = true;
	 	 $unique_fields = [];

	 	 for($f = 0; $f < count($this->meta->unique_fields); $f++){
	 	 	 if( !isset($this->meta->fields[$this->meta->unique_fields[$f]]) ){
	 	 	 	 $all_defined = false;
	 	 	 	 break;
	 	 	 }

	 	 	 $db_col = $this->meta->column_names[$this->meta->unique_fields[$f]];
	 	 	 if(isset($data[$db_col])){
	 	 	 	 $unique_fields[$db_col] = $data[$db_col];
	 	 	 }
	 	 }

	 	 if(!$all_defined){
	 	 	throw new \Exception("One or more field names provided in meta unique_fields key is not valid!");
	 	 }

	 	 if( count($unique_fields) < count($this->meta->unique_fields) ){
	 	 	 return false;
	 	 }

         $unique_field_keys = array_keys($unique_fields);
         $first_field = array_shift($unique_field_keys);
         $dao = self::class;
         if(str_contains($dao, "Throughs")){
         	 $manager = $dao::db2($table_name, $model_class, $db_class)->where($first_field."__eq", $unique_fields[$first_field]);
         }else{
         	 $manager = $dao::db()->where($first_field."__eq", $unique_fields[$first_field]);
         }
	 	 foreach($unique_field_keys as $uf){
	 	 	 $manager = $this->meta['unique_together'] ? $manager->where($uf."__eq", $unique_fields[$uf]) : $manager->or_where($uf."__eq", $unique_fields[$uf]);
	 	 }
	 	 $exists = $manager->limit(records: 1, page: 1)->first_or_default();

	 	 if(!$exists){
	 	 	 return false;
	 	 }

	 	 return [$exists, $unique_fields, $this->meta['unique_together']];
	 }

     private function swap_properties_with_columns($data){
     	 $swapped = [];
     	 foreach($this->meta->fields as $pk => $pv){
     	 	 $ck = $this->meta->fields[$pk]->column_name;
     	 	 if( array_key_exists($ck, $data) || array_key_exists($pk, $data) ){
     	 	 	 $swapped[$ck] = $data[$ck] ?? $data[$pk];
     	 	 }
     	 }
     	 return $swapped;
     }

	 public function prepare_insert_data($data, $request, $table_name = null, $model_class = null, $db_class = null, $skip_validation = false){
	 	/**
	 	 * Make sure data only uses db column names.
	 	 * */
	 	 $data = $this->swap_properties_with_columns($data);

	 	/**
	 	 * check an attempt to insert duplicate data.
	 	 * */
	 	 $is_duplicate = $this->check_if_duplicate($data, $table_name, $model_class, $db_class);

	 	 /**
	 	  * Inject creator and modifier fields, created and modified date time fields and deleted fields
	 	  * */
	 	 if($this->meta->auto_cm){
	 	 	$data[$this->meta->created_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 	$data[$this->meta->modified_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 }
	 	 if($this->meta->auto_cmdt){
	 	 	 $data[$this->meta->created_at_field] = time(); #current date time.
	 	 	 $data[$this->meta->modified_at_field] = time(); #Current date time
	 	 }
	 	 if($this->meta->soft_delete){
	 	 	 $data[$this->meta->deleted_field] = 0; #0 or 1, will be updated according to the operation
	 	 	 $data[$this->meta->deleted_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 	 $data[$this->meta->deleted_at_field] = time(); #current date and time stamp
	 	 }

	 	 /**
	 	  * Get validated data.
	 	  * */
	 	 $clean_data = !$skip_validation ? $this->get_clean_data($data, "insert") : $data;

	 	 /**
	 	  * Generate GUID if the primary key is of that type.
	 	  * */
	 	 if($this->meta->pk_type === 'GUID'){
	 	 	$clean_data[$this->meta->pk_name] = $this->guid();
	 	 }

	 	 /**
	 	  * Get file data if any.
	 	  * */
	 	 $file_data = $this->prepare_file_data($clean_data);

	 	 return [$clean_data, $file_data, $is_duplicate, $this->meta->action_on_duplicate];
	 }

	 public function prepare_update_data($data, $request, $data_state = null, $skip_validation = false){
	 	 /**
	 	 * Make sure data only uses db column names.
	 	 * */
	 	 $data = $this->swap_properties_with_columns($data);

	 	 /**
	 	 * Before anything else happens,
	 	 * check an attempt to insert duplicate data.
	 	 * */
	 	 $is_duplicate = $this->check_if_duplicate($data);

	 	 /**
	 	  * Inject modifier and modified date time fields
	 	  * */
	 	 if($this->meta->auto_cm){
	 	 	$data[$this->meta->modified_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 }
	 	 if($this->meta->auto_cmdt){
	 	 	 $data[$this->meta->modified_at_field] = time(); #Current date time
	 	 }

	 	 /**
	 	  * Get validated data
	 	  * */
	 	 $clean_data = !$skip_validation ? $this->get_clean_data($data, "update") : $data;

	 	 /**
	 	  * For models supporting soft delete, the deleted field(Whatever name its called in meta),
	 	  * must not be updated from here.
	 	  * */
	 	 unset($clean_data[$this->meta->deleted_field]);

	 	  /**
	 	  * Prepare file data.
	 	  * */
	 	 $file_data = $this->prepare_file_data($clean_data, $data_state);

	 	 /**
	 	  * If there is primary key field, remove it too
	 	  * */
	 	 if(isset($clean_data[$this->meta->pk_name])){
	 	 	unset($clean_data[$this->meta->pk_name]);
	 	 }

	 	 return [$clean_data, $file_data, $is_duplicate, $this->meta->action_on_duplicate];
	 }

	 public function get_field_definitions(){
	 	 $defs = [];
     	 foreach($this->meta->fields as $fn => $fv){
     	 	 $fd = $fv->get_field_definition();
     	 	 if($fd){
     	 	 	 $defs[] = $fd;
     	 	 }
     	 }
     	 return $defs;
	 }

	 public function get_auto_include(){
	 	$auto_includes = [];
	 	foreach($this->meta->fields as $fn => $fv){
	 		if($fv instanceof Relation && $fv->eager){
	 			$auto_includes[] = ['relation' => $fv->get_relation(), 'with' => '', 'tuning' => null];
	 		}
	 	}
	 	return $auto_includes;
	 }

	 public function is_include(string $field){
	 	 $includes = array_merge($this->meta->fk_field_names, $this->meta->nav_field_names);

	 	 if(!in_array($field, $includes)){
	 		$field = array_flip($this->meta->column_names)[$field];
	 		if(!in_array($field, $includes)){
	 			 return false;
	 		}
	 	 }

	 	 $instance = $this->meta->fields[$field] ?? null;
	 	 if(!$instance)
	 		 return false;

	 	 return $instance->get_relation();
	 }

	 /**
	  * Check that a model has a relationship with another model defined on one of the fields
	  * and return the relation.
	  * */
	 public function has_relationship_with(string $model_class){
	 	 $relation = false;
         $relation_fields = array_merge($this->meta->nav_field_names, $this->meta->fk_field_names);
         for($f = 0; $f < count($relation_fields); $f++){
         	 $field = $this->meta->fields[$relation_fields[$f]];
         	 if($field->get_relation()->fmodel == $model_class){
         	 	$relation = $field;
         	 }
         }
         return $relation;
	 }

	 public function has_manytomany_relationship_with(string $model_class){
	 	 $relation = false;
         for($f = 0; $f < count($this->meta->nav_field_names); $f++){
         	 $field = $this->meta->fields[$this->meta->nav_field_names[$f]];
         	 if($field->get_relation()->fmodel == $model_class && $field instanceof ManyToMany){
         	 	$relation = $field;
         	 }
         }
         return $relation;
	 }
}
?>