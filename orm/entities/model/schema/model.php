<?php
namespace SaQle\Orm\Entities\Model\Schema;

use SaQle\Orm\Entities\Field\Relations\Interfaces\IRelation;
use SaQle\Services\Container\ContainerService;
use SaQle\Services\Container\Cf;
use SaQle\Orm\Entities\Field\Interfaces\IField;
use SaQle\Orm\Entities\Field\Types\{Pk, TextField, OneToOne, OneToMany, FloatField, IntegerField, BigIntegerField, PhpTimestampField, ManyToMany, FileField, TinyTextField, DateField, TimeField, DateTimeField, TimestampField, BooleanField};
use SaQle\Orm\Entities\Field\Exceptions\FieldValidationException;
use SaQle\Security\Models\ModelValidator;
use SaQle\Commons\StringUtils;
use SaQle\Orm\Entities\Field\Types\Base\Relation;
use SaQle\Orm\Entities\Model\Manager\ModelManager;
use SaQle\Orm\Entities\Model\Interfaces\{IModel, IThroughModel, ITableSchema, ITempModel};
use SaQle\Orm\Entities\Model\Collection\ModelCollection;
use JsonSerializable;

abstract class Model implements ITableSchema, IModel, JsonSerializable{
	 use StringUtils;

     /**
      * A key => value array of raw model data: keys are field names.
      * Values may be simple, other model objects or arrays of model objects
      * */
	 protected private(set) array $data = []{
	 	 set(array $value){
		 	 $this->data = $this->format_data($value);
	 	 }

	 	 get => $this->data;
	 }

     /**
      * A memory record of data between the time it is set and the time
      * updates are made on the data
      * */
	 private $data_state = [];

	 /**
	  * Static cache to store shared metadata per class
	  * */
     private static array $shared_meta = [];

	 /**
	  * Virtual property that gets all the information about a table scehema
	  * */
	 public mixed $meta {
 	 	 get => $this->get_shared_meta(static::class);
	 }

	 protected static array $instances = [];
	 
	 public function __construct(...$kwargs){
	 	 $this->data = $kwargs;
	 	 $this->data_state = $this->get_data_state();
     }

     //method to ensure shared meta per class
     private function get_shared_meta(string $class_name): TableInfo {
         //Check if meta already exists for this class
         if(!isset(self::$shared_meta[$class_name])) {
             $table_info = new TableInfo();
             [$db_class, $table_name] = self::get_table_n_dbcontext();
	 	     $table_info->db_table    = $table_name;
	 	     $table_info->db_class    = $db_class;
	 	     $table_info->model_class = $this::class;
             $this->model_setup($table_info);
             self::$shared_meta[$class_name] = $table_info;
         }

         //return the shared meta for this class
         return self::$shared_meta[$class_name];
     }

     //abstract method that must be implemented by concrete classes to define fields
     abstract protected function model_setup(TableInfo $meta): void;

     final public static function state(){
         $called_class = get_called_class();
         if (!isset(self::$instances[$called_class])){
             self::$instances[$called_class] = new $called_class();
         }

         return self::$instances[$called_class];
     }

	 public static function db2($table_name, $model_class, $db_class, $table_aliase = null, $table_ref = null){
	 	 $manager = Cf::create(ContainerService::class)->createContextModelManager($db_class);
         $manager->initialize(
         	table_name:      $table_name, 
         	dbcontext_class: $db_class, 
         	model_class:     $model_class,
         	table_aliase:    $table_aliase,
         	table_ref:       $table_ref
         );
         return $manager;
	 }

	 public static function db($table_aliase = null, $table_ref = null){
	 	 $called_class = get_called_class();
	 	 [$db_class, $table_name] = $called_class::get_table_n_dbcontext();
	 	 
	 	 $manager = Cf::create(ContainerService::class)->createContextModelManager($db_class);
         $manager->initialize(
             table_name:      $table_name, 
         	 dbcontext_class: $db_class, 
         	 table_aliase:    $table_aliase,
         	 table_ref:       $table_ref
         );
         return $manager;
	 }

	 public static function get_table_n_dbcontext(){
	 	 $db_class = false;
	 	 $table_name = null;
	 	 $current_model_name = get_called_class();
	 	 $interfaces = class_implements($current_model_name);
	 	 
	 	 /**
	 	  * Note:
	 	  * For regular models defined by the user, the model is expected to have been registered with
	 	  * one or more database contexts.
	 	  * 
	 	  * For through models generated by makemigations command, the model may not be 
	 	  * registered with any databasecontext, therefore it will use the contexts of one of the related models.
	 	  * */
	 	 if(in_array(ITempModel::class, $interfaces)){
	 	 	 return ['', ''];
	 	 }elseif(in_array(IThroughModel::class, $interfaces)){
	 	 	 $related_models = $current_model_name::get_related_models();
	 	 	 if(!$related_models){
	 	 	 	throw new \Exception("A through model must have at least two related models!");
	 	 	 }

	 	 	 $first_model = $related_models[0];
	 	 	 [$db_class, $table_name] = $first_model::get_table_n_dbcontext();
	 	 }else{
	 	 	 $context_classes = array_keys(DB_CONTEXT_CLASSES);
		 	 for($x = 0; $x < count($context_classes); $x++){
		 	 	$context_class_name = $context_classes[$x];
		 	 	$models = $context_class_name::get_models();
		 	 	$model_classes = array_values($models);
		 	 	if(in_array($current_model_name, $model_classes)){
		 	 		$db_class = $context_class_name;
		 	 		$table_name = array_keys($models)[array_search($current_model_name, $model_classes)];
		 	 		break;
		 	 	}
		 	 }
	 	 } 

	 	 if(!$db_class || !$table_name){
	 	 	throw new \Exception($current_model_name.": Model not registered with any db contexts!");
	 	 }
	 	 return [$db_class, $table_name];
	 }

     public function get_validation_configurations(?array $field_names = null){
     	 $vc = [];
     	 foreach($this->meta->fields as $fn => $fv){
     	 	 $column_name = $fv->column_name;
     	 	 if(!$field_names || (($field_names && in_array($fn, $field_names)) || ($field_names && in_array($column_name, $field_names)))){
     	 	 	 $fvc = $fv->get_validation_configurations();
	     	 	 if($fvc){
	     	 	 	 $vc[$column_name] = $fvc;
	     	 	 }else{
	     	 	 	 $vc[$column_name] = false;
	     	 	 }
     	 	 }
     	 }
     	 return $vc;
     }

	 public function get_clean_data(array $data, string $operation = ''){
	 	 /**
	 	  * strip the data array of keys of the following:
	 	  * 1. All keys that are not field names of current model
	 	  * 2. PrimaryKey key: GUID key values will be auto generated by the application,
	 	  *    while AUTO key values are generated by the db engine on insert
	 	  * */
	 	 $original_data = $data;
     	 $tmp_data = [];
     	 $model_field_names = array_unique(array_merge(array_keys($this->meta->column_names), array_values($this->meta->column_names)));
     	 foreach(array_keys($data) as $_dk){
     	 	if(in_array($_dk, $model_field_names) && $_dk != $this->meta->pk_name && !in_array($_dk, $this->meta->nav_field_names)){
     	 		$tmp_data[$_dk] = $data[$_dk];
     	 	}
     	 }
     	 
     	 $data = $tmp_data;


         /**
          * The following field types will be excempted from validation, atleast for now.
          * 1. All navigation keys
          * 2. All file keys whose value in data is just file name. In the future, it should be possible
          *    to validate just the file name.
          * */
	 	 $vc = $operation == 'update' ? $this->get_validation_configurations(array_keys($data)) : $this->get_validation_configurations();
	 	 $file_names_only = [];
	 	 foreach($this->meta->file_field_names as $ffn){
	 	 	if(isset($data[$ffn]) && !is_array($data[$ffn])){
	 	 		$file_names_only[$ffn] = $data[$ffn];
	 	 	}
	 	 }

	 	 $exclude = array_merge(array_keys($file_names_only), $this->meta->nav_field_names);
	 	 foreach($vc as $vc_key => $vc_val){
	 	 	if(in_array($vc_key, $exclude)){
	 	 		unset($vc[$vc_key]);
	 	 	}
	 	 }

	 	 $validation_feedback = ModelValidator::validate($vc, $data);
		 if($validation_feedback["status"] !== 0){
			 throw new FieldValidationException([
			 	'model' => $this::class,
			 	'operation' => $operation,
			 	'dirty' => $validation_feedback['dirty']
			 ]);
		 }

		 /**
		  * In update operations, the primary key and value needs be reinserted into data here.
		  * TO DO: Find a way of avoiding this altogether.
		  * */
		 if($operation == 'update' && isset($original_data[$this->meta->pk_name])){
		 	$validation_feedback['clean'][$this->meta->pk_name] = $original_data[$this->meta->pk_name];
		 }
		 return array_merge($validation_feedback['clean'], $file_names_only);
	 }

     private function rename_uploaded_files($field, &$clean_data, $file_key, $data_state = null){
	 	$original_clean_data = $clean_data;
	 	if(is_array($clean_data[$file_key]['name'])){
             foreach($clean_data[$file_key]['name'] as $n_index => $n){
                 $clean_data[$file_key]['name'][$n_index] = $field->rename(
                 	$data_state ? (Object)$data_state : (Object)$original_clean_data, 
                 	$clean_data[$file_key]['name'][$n_index], 
                 	$n_index
                 );
             }
         }else{
             $clean_data[$file_key]['name'] = $field->rename(
             	$data_state ? (Object)$data_state : (Object)$original_clean_data, 
             	$clean_data[$file_key]['name']
             );
         }
	 }

	 private function prepare_file_data(&$clean_data, $data_state = null){
	 	 /**
	 	  * Prepare files data: Only the file names will be saved in db.
	 	  * 1. Rename the files using the rename callback that was provided on the model if any
	 	  * 2. Get the file path using the path callback that was provided on the model if any.
	 	  * 3. Reset the file values in clean data to file names only
	 	  * */
	 	 $file_data = [];
	 	 foreach($this->meta->file_field_names as $ffn){
	 	 	$db_col = $this->meta->column_names[$ffn];
	 	 	#if the file exists.
	 	 	if(isset($clean_data[$db_col]) && is_array($clean_data[$db_col])){
	 	 		 //print_r($this->meta->fields[$ffn]);
	 	 		 $file_config = [
	 	 		 	 'crop_dimensions'   => $this->meta->fields[$ffn]->crop_dimensions, 
	 	 		     'resize_dimensions' => $this->meta->fields[$ffn]->resize_dimensions
	 	 		 ];

	 	 		 //rename files
	 	 		 $this->rename_uploaded_files($this->meta->fields[$ffn], $clean_data, $db_col, $data_state);

	 	 		 //get the file path
	 	 		 $file_config['path'] = $this->meta->fields[$ffn]->path($data_state ? (Object)$data_state : (Object)$clean_data);
	 			 $file_data[$db_col] = (Object)['file' => $clean_data[$db_col], 'config' => $file_config];

	 			 //reset the file value in clean data to file names only.
	     	     $clean_data[$db_col] = is_array($clean_data[$db_col]['name']) ? implode("~", $clean_data[$db_col]['name']) : $clean_data[$db_col]['name'];
	 	 	}
	 	 }
	 	 return $file_data;
	 }

	 private function check_if_duplicate($data, $table_name = null, $model_class = null, $db_class = null){
	 	 if(!$this->meta->unique_fields){
	 	 	 return false;
	 	 }

	 	 /**
	 	  * Check that the fields provided are defined in model.
	 	  * */
	 	 $all_defined = true;
	 	 $unique_fields = [];

	 	 for($f = 0; $f < count($this->meta->unique_fields); $f++){
	 	 	 if( !isset($this->meta->fields[$this->meta->unique_fields[$f]]) ){
	 	 	 	 $all_defined = false;
	 	 	 	 break;
	 	 	 }

	 	 	 $db_col = $this->meta->column_names[$this->meta->unique_fields[$f]];
	 	 	 if(isset($data[$db_col])){
	 	 	 	 $unique_fields[$db_col] = $data[$db_col];
	 	 	 }
	 	 }

	 	 if(!$all_defined){
	 	 	throw new \Exception("One or more field names provided in meta unique_fields key is not valid!");
	 	 }

	 	 if( count($unique_fields) < count($this->meta->unique_fields) ){
	 	 	 return false;
	 	 }

         $unique_field_keys = array_keys($unique_fields);
         $first_field = array_shift($unique_field_keys);
         $dao = $this::class;
         if(str_contains($dao, "Throughs")){
         	 $manager = $dao::db2($table_name, $model_class, $db_class)->where($first_field."__eq", $unique_fields[$first_field]);
         }else{
         	 $manager = $dao::db()->where($first_field."__eq", $unique_fields[$first_field]);
         }
	 	 foreach($unique_field_keys as $uf){
	 	 	 $manager = $this->meta->unique_together ? $manager->where($uf."__eq", $unique_fields[$uf]) : $manager->or_where($uf."__eq", $unique_fields[$uf]);
	 	 }
	 	 $exists = $manager->limit(records: 1, page: 1)->first_or_default();

	 	 if(!$exists){
	 	 	 return false;
	 	 }

	 	 return [$exists, $unique_fields, $this->meta->unique_together];
	 }

     private function swap_properties_with_columns($data){
     	 $swapped = [];
     	 foreach($this->meta->fields as $pk => $pv){
     	 	 $ck = $this->meta->fields[$pk]->column_name;
     	 	 if( array_key_exists($ck, $data) || array_key_exists($pk, $data) ){
     	 	 	 $swapped[$ck] = $data[$ck] ?? $data[$pk];
     	 	 }
     	 }
     	 return $swapped;
     }

	 public function prepare_insert_data($data, $request, $table_name = null, $model_class = null, $db_class = null, $skip_validation = false){
	 	/**
	 	 * Make sure data only uses db column names.
	 	 * */
	 	 $data = $this->swap_properties_with_columns($data);

	 	/**
	 	 * check an attempt to insert duplicate data.
	 	 * */
	 	 $is_duplicate = $this->check_if_duplicate($data, $table_name, $model_class, $db_class);

	 	 /**
	 	  * Inject creator and modifier fields, created and modified date time fields and deleted fields
	 	  * */
	 	 if($this->meta->auto_cm){
	 	 	$data[$this->meta->created_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 	$data[$this->meta->modified_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 }
	 	 if($this->meta->auto_cmdt){
	 	 	 $data[$this->meta->created_at_field] = time(); #current date time.
	 	 	 $data[$this->meta->modified_at_field] = time(); #Current date time
	 	 }
	 	 if($this->meta->soft_delete){
	 	 	 $data[$this->meta->deleted_field] = 0; #0 or 1, will be updated according to the operation
	 	 	 $data[$this->meta->deleted_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 	 $data[$this->meta->deleted_at_field] = time(); #current date and time stamp
	 	 }

	 	 /**
	 	  * Get validated data.
	 	  * */
	 	 $clean_data = !$skip_validation ? $this->get_clean_data($data, "insert") : $data;

	 	 /**
	 	  * Generate GUID if the primary key is of that type.
	 	  * */
	 	 if($this->meta->pk_type === 'GUID'){
	 	 	$clean_data[$this->meta->pk_name] = $this->guid();
	 	 }

	 	 /**
	 	  * Get file data if any.
	 	  * */
	 	 $file_data = $this->prepare_file_data($clean_data);

	 	 return [$clean_data, $file_data, $is_duplicate, $this->meta->action_on_duplicate];
	 }

	 public function prepare_update_data($data, $request, $data_state = null, $skip_validation = false){
	 	 /**
	 	 * Make sure data only uses db column names.
	 	 * */
	 	 $data = $this->swap_properties_with_columns($data);

	 	 /**
	 	 * Before anything else happens,
	 	 * check an attempt to insert duplicate data.
	 	 * */
	 	 $is_duplicate = $this->check_if_duplicate($data);

	 	 /**
	 	  * Inject modifier and modified date time fields
	 	  * */
	 	 if($this->meta->auto_cm){
	 	 	$data[$this->meta->modified_by_field] = $request->user->user_id ?? 0; #Id of current user
	 	 }
	 	 if($this->meta->auto_cmdt){
	 	 	 $data[$this->meta->modified_at_field] = time(); #Current date time
	 	 }

	 	 /**
	 	  * Get validated data
	 	  * */
	 	 $clean_data = !$skip_validation ? $this->get_clean_data($data, "update") : $data;

	 	 /**
	 	  * For models supporting soft delete, the deleted field(Whatever name its called in meta),
	 	  * must not be updated from here.
	 	  * */
	 	 unset($clean_data[$this->meta->deleted_field]);

	 	  /**
	 	  * Prepare file data.
	 	  * */
	 	 $file_data = $this->prepare_file_data($clean_data, $data_state);

	 	 /**
	 	  * If there is primary key field, remove it too
	 	  * */
	 	 if(isset($clean_data[$this->meta->pk_name])){
	 	 	unset($clean_data[$this->meta->pk_name]);
	 	 }

	 	 return [$clean_data, $file_data, $is_duplicate, $this->meta->action_on_duplicate];
	 }

	 public function get_field_definitions(){
	 	 $defs = [];
     	 foreach($this->meta->fields as $fn => $fv){
     	 	 $fd = $fv->get_field_definition();
     	 	 if($fd){
     	 	 	 $defs[] = $fd;
     	 	 }
     	 }
     	 return $defs;
	 }

     private function assert_field_defined(string $field_name, bool $throw_error = false) : string | null{
     	 //ensure field is defined in model meta
	 	 if(!array_key_exists($field_name, $this->meta->fields) && !array_key_exists($field_name, $this->meta->column_names)){
	 	 	 $flipped_column_names = array_flip($this->meta->column_names);
	 	 	 $field_name = $flipped_column_names[$field_name] ?? null;
	 	 	 if(!$field_name){
	 	 	 	 if($throw_error){
	 	 	 	 	 throw new \Exception("The field ".$name." is not defined on the model ".$this::class);
	 	 	 	 }
	 	 	 	 return null;
	 	 	 }
	 	 }

	 	 return $field_name;
     }

	 public function __get($name){
	 	 $field_name = $this->assert_field_defined($name);
	 	 if(!$field_name){
	 	 	 return $this->data[$name] ?? null;
	 	 }

	 	 return $this->meta->fields[$field_name]->render($this->format_data($this->data, 'columns'));
     }

     public function get_field(string $field_name) : IField{
     	 $field_name     = $this->assert_field_defined($field_name, true);
     	 $field          = $this->meta->fields[$field_name];
     	 $field->content = $this->format_data($this->data, 'columns');
     	 return $field;
     }

     public function __set($name, $value){
         $this->data = array_merge($this->data, [$name => $value]);
     }

     /**
      * Check whether a field is a relation field defined on a model
      * and return the relation or false otherwise
      * */
     public function is_relation_field(string $field){
	 	 $includes = array_merge($this->meta->fk_field_names, $this->meta->nav_field_names);

	 	 if(!in_array($field, $includes)){
	 		$field = array_flip($this->meta->column_names)[$field];
	 		if(!in_array($field, $includes)){
	 			 return false;
	 		}
	 	 }

	 	 $instance = $this->meta->fields[$field] ?? null;
	 	 if(!$instance)
	 		 return false;

	 	 return $instance->get_relation();
	 }

     /**
      * Classify defined model fields into different groups
      * */
     private function classify_fields(){
	 	 $defined_field_names = $this->meta->defined_field_names;
	 	 $nk_field_names      = $this->meta->nav_field_names;
	 	 $fk_field_names      = $this->meta->fk_field_names;
	 	 $simple_fields       = array_diff($defined_field_names, array_merge($nk_field_names, $fk_field_names));
	 	 $nk_fields           = array_diff($defined_field_names, array_merge($simple_fields, $fk_field_names));
	 	 $fk_fields           = array_diff($defined_field_names, array_merge($simple_fields, $nk_field_names));
	 	 return [$defined_field_names, $simple_fields, $fk_fields, $nk_fields];
     }

     /**
      * Initialize the data state athe time of model instantiation
      * */
     private function get_data_state(){
	 	 $data_state = [];
	 	 [$defined_field_names, $simple_fields, $fk_fields, $nk_fields] = $this->classify_fields();

	     foreach($defined_field_names as $field){
	     	 if(in_array($field, $simple_fields)){
	     	 	 $data_state[$field] = $this->data[$field] ?? null;
	     	 }elseif(in_array($field, $fk_fields) || in_array($field, $nk_fields)){
	     	 	 $val = $this->data[$field] ?? null;
	     	 	 if($val instanceof IModel){
	     	 	 	 $relation = $this->is_relation_field($property_name);
	     	 	     $fk_name = $relation->fk;
	     	 	     $pk_values = $val->$fk_name;
	     	 	     $data_state[$field] = $pk_values;
	     	 	     if(in_array($field, $nk_fields) && $relation instanceof Many2Many){
	     	 	     	 [$table_name, $model, $ctx] = $relation->get_through_model();
	     	 	     	 $data_state[$field] = ['key' => $fk_name, 'values' => $pk_values, 'table' => $table_name, 'model' => $model, 'context' => $ctx];
	     	 	     }
	     	 	 }else{
	     	 	 	 $data_state[$field] = $val;
	     	 	 }
	     	 }
	     }
	     return $data_state;
	 }

     /**
      * Detect whether object data has been updated and return the updated state
      * */
	 public function get_state_change($new_data_state = null, $update_optional = null){
	 	 $simple_changed = [];
	 	 $fk_changed = [];
	 	 $nk_changed = [];
	 	 [$defined_field_names, $simple_fields, $fk_fields, $nk_fields] = $this->classify_fields();
	 	 $new_data_state = $new_data_state ?? $this->get_data_state();

	 	 foreach($new_data_state as $key => $val){
	 	 	 if($val != $this->data_state[$key] && ( !is_null($val) && $val != '')){ //This null and empty string condition must be rechecked!
	 	 	 	 if(in_array($key, $simple_fields)){
		 	 	 	 $simple_changed[$key] = $val;
		 	 	 }elseif(in_array($key, $fk_fields)){
		 	 	 	 $fk_changed[$key] = $val;
		 	 	 }elseif(in_array($key, $nk_fields)){
		 	 	 	 /**
		 	 	 	  * I am assuming this is many to many navigation key, this part must be reworked
		 	 	 	  * to accomodate many to one and one to one cases as well
		 	 	 	  * */
		 	 	 	 $current_values = $val['values'];
		 	 	 	 $former_values = $this->data_state[$key]['values'];

		 	 	 	 $added_values = array_diff($current_values, $former_values);
		 	 	 	 $removed_values = array_diff($former_values, $current_values);

		 	 	 	 $val['added'] = $added_values;
		 	 	 	 $val['removed'] = $removed_values;

		 	 	 	 $nk_changed[$key] = $val;
		 	 	 }
	 	 	 }
	 	 }
	 	 return [$simple_changed, $fk_changed, $nk_changed];
	 }

     /**
      * When attempting to save an updated object, this returns those properties
      * that are savable.
      * */
	 public function get_savable_values(){
	 	 $savable_simple = [];
	 	 $savable_fk = [];
	 	 $savable_nk = [];

	 	 [$defined_field_names, $simple_fields, $fk_fields, $nk_fields] = $this->classify_fields();

	     foreach($defined_field_names as $field){
	     	 /**
              * Only take fields with values
              * - validation mechanism will determine whether all the properties required for a successful save are there or not, so don't worry about it here.
              * Also take only those properties that wer explicitly defined on the schema associated with this model.
              * */
			 $val = $this->$field;
		     if(in_array($field, $simple_fields)){
	     	 	 $savable_simple[$field] = [$val, false];
	     	 }elseif(in_array($field, $nk_fields)){
                 $savable_nk[$field] = [$val, $this->is_relation_field($field)];
	     	 }elseif(in_array($field, $fk_fields)){
                 $savable_fk[$field] = [$val, $this->is_relation_field($field)];
	     	 }
	     }

	     return [$savable_simple, $savable_nk, $savable_fk, $this->meta->pk_name];
	 }

	 /**
	  * This save assumes the data was set via the model instructor.
	  * Notes on save:
	  * 1. By default only simple values are saved or updated when save is called.
	  * 2. Relation values(OneToOne, OneToMany, ManyToMany) will only be saved when explicitly requested via 'with' interface
	  * 3. While new relation objects can be created, they cannot be updated from here. Update relation objects via their own models.
	  * 4. Values for properties that were not explicitly defined i.e values generated by auto_cm_fields, auto_cmdt_fields, soft_delete and enable_multitenancy flags will be filled in automatically. If there are values assigned for these properties here, they will be ignored.
	  * */
	 public function save(?array $update_optional = null){
	 	 $current_data_state = $this->get_data_state();
	     
	 	 [$savable_simple, $savable_nk, $savable_fk, $pk_name] = $this->get_savable_values();
	 	 $with_fields = [];

	 	 #If there are foreign relations, save them first. FK relations are one to one, so the save is expected to return a single object.
	 	 $saved_fk_ids = [];
	 	 foreach($savable_fk as $fk_key => $fk_value){
	 	 	 if(isset($fk_value[0])){
	 	 	 	$with_fields[] = $fk_key;
		 	 	 $s = $fk_value[0]->save();
		 	 	 if($s){
		 	 	 	 $fk_name = $fk_value[1]->fk;
		 	 	 	 $saved_fk_ids[$fk_key] = $s->$fk_name;
		 	 	 }
	 	 	 }
	 	 }

	 	 #Save the current object next.
	 	 $object = null;
	 	 $object_data = array_combine(array_keys($savable_simple), array_column(array_values($savable_simple), 0));
	 	 if(isset($savable_simple[$pk_name][0])){ //this object has a value for primary key field.
	 	 	 
	 	 	 #acquire the object
	 	 	 $object = self::db()->with(array_merge(array_keys($savable_nk), array_keys($savable_fk)))
	 	 	 ->where($pk_name, $savable_simple[$pk_name][0])->tomodel(true)->first_or_default();

	 	 	 if($object){

	 	 	 	 #get the changes made
	 	 	 	 [$simple_changed, $fk_changed, $nk_changed] = $this->get_state_change($current_data_state, $update_optional);
	 	 	 	 $simple_changes = array_merge($simple_changed, $fk_changed);
	 	 	 	 if($simple_changes){
	 	 	 	 	 #attempt an update
		 	 	 	 self::db()->set_data_state($current_data_state)->where($pk_name, $savable_simple[$pk_name][0])
		 	 	 	 ->set($simple_changes)->tomodel(true)->update();
	 	 	 	 }
                 
	 	 	 	 #remove any many to many bondings that are no longer existing.
	 	 	 	 foreach($nk_changed as $nkf => $nkv){
	 	 	 	 	 if($nkv['removed']){
	 	 	 	 	 	 $tm = $nkv['model']; //table model
                 	     $tm::db2($nkv['table'], $tm, $nkv['context'])->where($nkv['key']."__in", $nkv['removed'])->delete(permanently: true);
	 	 	 	 	 }
                 }
	 	 	 }
	 	 }
         
         #save object in db if its null upto this point
	 	 if(!$object)
	 	 	 $object = self::db()->set_data_state($current_data_state)->add(array_merge($object_data, $saved_fk_ids))->tomodel(true)->save();

	 	 #abort save operation if object its still null at this point.
	 	 if(!$object)
	 	  	 throw new \Exception("Save operation aborted! This object could not be saved.");
	 	 
	 	 #save navigation key data
	 	 $saved_nk_ids = [];
	 	 foreach($savable_nk as $nk_key => $nk_value){
	 	 	 if(!is_null($nk_value[0])){
	 	 	 	 $with_fields[] = $nk_key;
		 	 	 $nk_pk_name = $nk_value[1]->pk;
		 	 	 $nk_fk_name = $nk_value[1]->fk;
		 	 	 $nk_pk_value = $object->$nk_pk_name;

		 	 	 if(is_array($nk_value[0]) && count($nk_value[0]) > 0){
		 	 	 	 $colection = new ModelCollection(type: $nk_value[0][0]::class, elements: $nk_value[0]);
		 	 	 	 $s = $colection->save();
	 	 	 	 	 $saved_nk_ids[$nk_key] = [$nk_pk_value, $s->$nk_fk_name, $nk_value[1]->get_through_model(), $nk_pk_name, $nk_fk_name];
	 	 	 	 	 //print_r($saved_nk_ids);
	 	 	 	 }else{
	 	 	 	 	 $nk_fk_name = $nk_value[1]->fk;
	 	 	 	 	 $nk_value[0]->$nk_fk_name = $nk_pk_value;
	 	 	 	 	 $s = $nk_value[0]->save();
	 	 	 	 }
	 	 	 }
	 	 }

	 	 #tie the navigation key data to object via through model
	 	 foreach($saved_nk_ids as $_nk => $_ids){
	 	 	 if(count($_ids[1]) > 0){
		 	 	 $through_model_schema = $_ids[2];
		 	 	 $through_model = $through_model_schema[1];
		 	 	 $data = [];
		 	 	 $pk_col_name = $through_model_schema[3];
		 	 	 $fk_col_name = $through_model_schema[4];
		 	 	 $pk_col_val = $_ids[0];
		 	 	 foreach($_ids[1] as $fk_col_val){
		 	 	 	 $data[] = [$pk_col_name => $pk_col_val, $fk_col_name => $fk_col_val];
		 	 	 }
		 	 	 $connected = $through_model::db2($through_model_schema[0], $through_model_schema[1], $through_model_schema[2])
		 	 	 ->add_multiple($data)->save();
		 	 }
	 	 }

	 	 $getmana = self::db()->set_data_state($current_data_state)->where($pk_name, $object->$pk_name);
	 	 if($with_fields){
	 	 	$getmana->with($with_fields);
	 	 }

	 	 return $getmana->tomodel(true)->first_or_default();
	 }

	 public function jsonSerialize() : mixed{
	 	 $formatted_data = [];
	 	 foreach($this->data as $key => $val){
	 	 	 $formatted_data[$key] = $this->$key;
	 	 }
         return $formatted_data;
     }

     private function format_data(array $data, string $keytype = 'fields'){
     	 $formatted_values = [];
 	     $db_columns = $this->meta->column_names;
 	     $db_columns_flip = array_flip($db_columns);
	 	 foreach($data as $k => $v){
	 	 	 $field_name = null;
	 	 	 $col_name   = null;
	 	 	 if(array_key_exists($k, $db_columns)){
	 	 	 	 $field_name = $k;
	 	 	 	 $col_name = $db_columns[$k];
	 	 	 }

	 	 	 if(!$field_name && !$col_name){
	 	 	 	 if(array_key_exists($k, $db_columns_flip)){
	 	 	 	     $col_name = $k;
	 	 	 	     $field_name = $db_columns_flip[$k];
	 	 	     }
	 	 	 }

	 	 	 if(!$field_name && !$col_name){
	 	 	 	 $formatted_values[$k] = $v;
	 	 	 	 continue;
	 	 	 }

	 	 	 if($keytype === 'fields'){
	 	 	 	 $formatted_values[$field_name] = $v;
	 	 	 }else{
	 	 	 	 $formatted_values[$col_name] = $v;
	 	 	 }
	 	 }

	 	 return $formatted_values;
     }
}
?>